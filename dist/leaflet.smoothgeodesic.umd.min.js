/*! Leaflet.SmoothGeodesic 1.0.0 - created by Hunter Evanoff - https://github.com/hunter547/Leaflet.SmoothGeodesic */
!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?s(require("leaflet")):"function"==typeof define&&define.amd?define(["leaflet"],s):s((t="undefined"!=typeof globalThis?globalThis:t||self).L)}(this,(function(t){"use strict";function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var e=s(t);const o=Math.PI/180,n=180/Math.PI;class i{constructor(t,s){this.lat=t,this.lon=s,this.x=o*s,this.y=o*t}view(){return String(this.lon).slice(0,4)+","+String(this.lat).slice(0,4)}antipode(){const t=-1*this.lat,s=this.lon<0?180+this.lon:-1*(180-this.lon);return new i(s,t)}}class h{constructor(){this.coords=[],this.length=0}moveTo(t){this.length++,this.coords.push(t)}}class a{constructor(t){this.properties=t||{},this.geometries=[]}}class r{constructor(t,s,e){if(!t||void 0===t[0]||void 0===t[1])throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");if(!s||void 0===s[0]||void 0===s[1])throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");this.start=new i(t[0],t[1]),this.end=new i(s[0],s[1]),this.properties=e||{};const o=this.start.x-this.end.x,n=this.start.y-this.end.y,h=Math.pow(Math.sin(n/2),2)+Math.cos(this.start.y)*Math.cos(this.end.y)*Math.pow(Math.sin(o/2),2);if(this.g=2*Math.asin(Math.sqrt(h)),this.g===Math.PI)throw new Error("it appears "+this.start.view()+" and "+this.end.view()+" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");if(isNaN(this.g))throw new Error("could not calculate great circle between "+t+" and "+s)}interpolate(t){const s=Math.sin((1-t)*this.g)/Math.sin(this.g),e=Math.sin(t*this.g)/Math.sin(this.g),o=s*Math.cos(this.start.y)*Math.cos(this.start.x)+e*Math.cos(this.end.y)*Math.cos(this.end.x),i=s*Math.cos(this.start.y)*Math.sin(this.start.x)+e*Math.cos(this.end.y)*Math.sin(this.end.x),h=s*Math.sin(this.start.y)+e*Math.sin(this.end.y);return[n*Math.atan2(h,Math.sqrt(Math.pow(o,2)+Math.pow(i,2))),n*Math.atan2(i,o)]}Arc(t,s){const e=1+Math.pow(2,t+1),o=[];if(!e||e<=2)o.push([this.start.lat,this.start.lon]),o.push([this.end.lat,this.end.lon]);else{const t=1/(e-1);for(let s=0;s<e;++s){const e=t*s,n=this.interpolate(e);o.push(n)}}let n=!1,i=0;const r=s&&s.offset?s.offset:10,c=180-r,u=-180+r,l=360-r;for(let t=1;t<o.length;++t){const s=o[t-1][1],e=o[t][1],h=Math.abs(e-s);h>l&&(e>c&&s<u||s>c&&e<u)?n=!0:h>i&&(i=h)}const p=[];if(n&&i<r){let t=[];p.push(t);for(let s=0;s<o.length;++s){const e=o[s][1];if(s>0&&Math.abs(e-o[s-1][1])>l){let n=o[s-1][1],i=o[s-1][0],h=o[s][1],a=o[s][0];if(n>-180&&n<u&&180===h&&s+1<o.length&&o[s-1][1]>-180&&o[s-1][1]<u){t.push([o[s][0],-180]),s++,t.push([o[s][0],o[s][1]]);continue}if(n>c&&n<180&&-180===h&&s+1<o.length&&o[s-1][1]>c&&o[s-1][1]<180){t.push([o[s][0],180]),s++,t.push([o[s][0],o[s][1]]);continue}if(n<u&&h>c){const t=n;n=h,h=t;const s=i;i=a,a=s}if(n>c&&h<u&&(h+=360),n<=180&&h>=180&&n<h){const e=(180-n)/(h-n),r=e*a+(1-e)*i;t.push([r,o[s-1][1]>c?180:-180]),t=[],t.push([r,o[s-1][1]>c?-180:180]),p.push(t)}else t=[],p.push(t);t.push([o[s][0],e])}else t.push([o[s][0],o[s][1]])}}else{const t=[];p.push(t);for(let s=0;s<o.length;++s)t.push([o[s][0],o[s][1]])}const d=new a(this.properties);for(let t=0;t<p.length;++t){const s=new h;d.geometries.push(s);const e=p[t];for(let t=0;t<e.length;++t)s.moveTo(e[t])}return d}}e.default.SmoothGeodesic=e.default.Path.extend({options:{},initialize:function(t,s,o,n){e.default.setOptions(this,n),this._coords=this._generateCoordinates(t,s,o),this._setPath(this._catmullRom2bezier())},_generateCoordinates:function(t,s,e){const o=new r(t,s),{geometries:n}=o.Arc(e);return n[0].coords},_catmullRom2bezier:function(){const t=["M",this._coords[0]],s=this._coords.flat();for(let e=0,o=s.length;o-2>e;e+=2){const n=[];0===e?(n.push({x:s[e],y:s[e+1]}),n.push({x:s[e],y:s[e+1]}),n.push({x:s[e+2],y:s[e+3]}),n.push({x:s[e+4],y:s[e+5]})):o-4===e?(n.push({x:s[e-2],y:s[e-1]}),n.push({x:s[e],y:s[e+1]}),n.push({x:s[e+2],y:s[e+3]}),n.push({x:s[e+2],y:s[e+3]})):(n.push({x:s[e-2],y:s[e-1]}),n.push({x:s[e],y:s[e+1]}),n.push({x:s[e+2],y:s[e+3]}),n.push({x:s[e+4],y:s[e+5]}));const i=[];i.push({x:n[1].x,y:n[1].y}),i.push({x:(-n[0].x+6*n[1].x+n[2].x)/6,y:(-n[0].y+6*n[1].y+n[2].y)/6}),i.push({x:(n[1].x+6*n[2].x-n[3].x)/6,y:(n[1].y+6*n[2].y-n[3].y)/6}),i.push({x:n[2].x,y:n[2].y}),t.push("C",[i[1].x,i[1].y],[i[2].x,i[2].y],[i[3].x,i[3].y])}return t},setLatLngs:function(t){return this.setPath(t)},getLatLngs:function(){return this.getPath()},getPath:function(){return this._pathData},setPath:function(t){return this._setPath(t),this.redraw()},getBounds:function(){return this._bounds},_setPath:function(t){console.log(t),this._pathData=t,this._bounds=this._computeBounds()},_isSmoothGeodesicSVGCommand:function(t){return-1!==["M","L","H","V","C","S","Q","T","Z"].indexOf(t)},_computeBounds:function(){const t=e.default.latLngBounds([]);let s,o="M";for(let n=0;n<this._pathData.length;n++)if(s=this._pathData[n],this._isSmoothGeodesicSVGCommand(s))o=s;else if("C"===o){const o=e.default.latLng(s[0],s[1]);s=this._pathData[++n];const i=e.default.latLng(s[0],s[1]);s=this._pathData[++n];const h=e.default.latLng(s[0],s[1]);t.extend(o),t.extend(i),t.extend(h),h.controlPoint1=o,h.controlPoint2=i}else t.extend(s);return console.log(t),t},getCenter:function(){return this._bounds.getCenter()},_update:function(){this._map&&this._updateCurveSvg()},_project:function(){let t,s=[0,0],o="M",n=e.default.point(0,0);const i=this._map;this._points=[];for(let h=0;h<this._pathData.length;h++)if(t=this._pathData[h],this._isSmoothGeodesicSVGCommand(t))this._points.push(t),o=t;else{switch(t.length){case 2:n=i.project(e.default.latLng(t[0],t[1])).subtract(i.getPixelOrigin()),s=t;break;case 1:if("H"===o){n=i.project(e.default.latLng(s[0],t[0])).subtract(i.getPixelOrigin()),s=[s[0],t[0]]}else{n=i.project(e.default.latLng(t[0],s[1])).subtract(i.getPixelOrigin()),s=[t[0],s[1]]}}this._points.push(n)}},_curvePointsToPath:function(t){let s,e="M",o="";for(let n=0;n<t.length;n++)if(s=t[n],"string"==typeof s&&this._isSmoothGeodesicSVGCommand(s))e=s,o+=e;else switch(e){case"H":o+=s.x+" ";break;case"V":o+=s.y+" ";break;default:o+=s.x+","+s.y+" "}return console.log(o),o||"M0 0"},beforeAdd:function(t){var s;null===(s=e.default.Path.prototype.beforeAdd)||void 0===s||s.call(this,t)},onAdd:function(t){if(e.default.Path.prototype.onAdd.call(this,t),this.options.animate&&this._path.animate){const t=this._svgSetDashArray();this.options.animate.delay&&this._path.animate([{strokeDashoffset:t},{strokeDashoffset:t}],{duration:this.options.animate.delay}),this._path.animate([{strokeDashoffset:t},{strokeDashoffset:0}],this.options.animate)}},_updateCurveSvg:function(){console.log(this._points),this._renderer._setPath(this,this._curvePointsToPath(this._points)),this.options.animate&&this._svgSetDashArray()},_svgSetDashArray:function(){const t=this._path,s=t.getTotalLength();return this.options.dashArray||(t.style.strokeDasharray=s+" "+s),s}}),e.default.smoothGeodesic=function(t,s,o,n){return new e.default.SmoothGeodesic(t,s,o,n||{})}}));
